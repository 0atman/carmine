<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>taoensso.carmine.protocol documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Carmine 2.4.0-RC1 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li><a href="taoensso.carmine.html"><span>taoensso.carmine</span></a></li><li><a href="taoensso.carmine.benchmarks.html"><span>taoensso.carmine.benchmarks</span></a></li><li><a href="taoensso.carmine.commands.html"><span>taoensso.carmine.commands</span></a></li><li><a href="taoensso.carmine.connections.html"><span>taoensso.carmine.connections</span></a></li><li><a href="taoensso.carmine.locks.html"><span>taoensso.carmine.locks</span></a></li><li><a href="taoensso.carmine.message-queue.html"><span>taoensso.carmine.message-queue</span></a></li><li><a href="taoensso.carmine.message-queue.html"><span>taoensso.carmine.message-queue</span></a></li><li class="current"><a href="taoensso.carmine.protocol.html"><span>taoensso.carmine.protocol</span></a></li><li><a href="taoensso.carmine.ring.html"><span>taoensso.carmine.ring</span></a></li><li><a href="taoensso.carmine.tundra.html"><span>taoensso.carmine.tundra</span></a></li><li><a href="taoensso.carmine.tundra.carmine.html"><span>taoensso.carmine.tundra.carmine</span></a></li><li><a href="taoensso.carmine.tundra.disk.html"><span>taoensso.carmine.tundra.disk</span></a></li><li><a href="taoensso.carmine.tundra.faraday.html"><span>taoensso.carmine.tundra.faraday</span></a></li><li><a href="taoensso.carmine.tundra.s3.html"><span>taoensso.carmine.tundra.s3</span></a></li><li><a href="taoensso.carmine.utils.html"><span>taoensso.carmine.utils</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="taoensso.carmine.protocol.html#var-*context*"><span>*context*</span></a></li><li><a href="taoensso.carmine.protocol.html#var-*parser*"><span>*parser*</span></a></li><li><a href="taoensso.carmine.protocol.html#var--%3EContext"><span>-&gt;Context</span></a></li><li><a href="taoensso.carmine.protocol.html#var--%3EWrappedRaw"><span>-&gt;WrappedRaw</span></a></li><li><a href="taoensso.carmine.protocol.html#var-IRedisArg"><span>IRedisArg</span></a></li><li><a href="taoensso.carmine.protocol.html#var-bs-%24"><span>bs-$</span></a></li><li><a href="taoensso.carmine.protocol.html#var-bs-*"><span>bs-*</span></a></li><li><a href="taoensso.carmine.protocol.html#var-bs-bin"><span>bs-bin</span></a></li><li><a href="taoensso.carmine.protocol.html#var-bs-clj"><span>bs-clj</span></a></li><li><a href="taoensso.carmine.protocol.html#var-bs-crlf"><span>bs-crlf</span></a></li><li><a href="taoensso.carmine.protocol.html#var-coerce-bs"><span>coerce-bs</span></a></li><li><a href="taoensso.carmine.protocol.html#var-get-basic-reply"><span>get-basic-reply</span></a></li><li><a href="taoensso.carmine.protocol.html#var-get-parsed-replies"><span>get-parsed-replies</span></a></li><li><a href="taoensso.carmine.protocol.html#var-map-%3EContext"><span>map-&gt;Context</span></a></li><li><a href="taoensso.carmine.protocol.html#var-map-%3EWrappedRaw"><span>map-&gt;WrappedRaw</span></a></li><li><a href="taoensso.carmine.protocol.html#var-parse"><span>parse</span></a></li><li><a href="taoensso.carmine.protocol.html#var-parser-comp"><span>parser-comp</span></a></li><li><a href="taoensso.carmine.protocol.html#var-raw"><span>raw</span></a></li><li><a href="taoensso.carmine.protocol.html#var-return"><span>return</span></a></li><li><a href="taoensso.carmine.protocol.html#var-send-request"><span>send-request</span></a></li><li><a href="taoensso.carmine.protocol.html#var-with-context"><span>with-context</span></a></li><li><a href="taoensso.carmine.protocol.html#var-with-replies"><span>with-replies</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>taoensso.carmine.protocol documentation</h2><pre class="doc">Facilities for actually communicating with Redis server using its
request/response protocol. Originally adapted from Accession.

Ref: http://redis.io/topics/protocol</pre><div class="public" id="var-*context*"><h3>*context*</h3><div class="usage"></div><pre class="doc"></pre></div><div class="public" id="var-*parser*"><h3>*parser*</h3><div class="usage"></div><pre class="doc"></pre></div><div class="public" id="var--%3EContext"><h3>-&gt;Context</h3><div class="usage"><code>(-&gt;Context in-stream out-stream parser-queue)</code></div><pre class="doc">Positional factory function for class taoensso.carmine.protocol.Context.
</pre></div><div class="public" id="var--%3EWrappedRaw"><h3>-&gt;WrappedRaw</h3><div class="usage"><code>(-&gt;WrappedRaw ba)</code></div><pre class="doc">Positional factory function for class taoensso.carmine.protocol.WrappedRaw.
</pre></div><div class="public" id="var-IRedisArg"><h3>IRedisArg</h3><div class="usage"></div><pre class="doc"></pre></div><div class="public" id="var-bs-%24"><h3>bs-$</h3><div class="usage"></div><pre class="doc"></pre></div><div class="public" id="var-bs-*"><h3>bs-*</h3><div class="usage"></div><pre class="doc"></pre></div><div class="public" id="var-bs-bin"><h3>bs-bin</h3><div class="usage"></div><pre class="doc"></pre></div><div class="public" id="var-bs-clj"><h3>bs-clj</h3><div class="usage"></div><pre class="doc"></pre></div><div class="public" id="var-bs-crlf"><h3>bs-crlf</h3><div class="usage"></div><pre class="doc"></pre></div><div class="public" id="var-coerce-bs"><h3>coerce-bs</h3><div class="usage"><code>(coerce-bs x)</code></div><pre class="doc">x -&gt; [&lt;ba&gt; &lt;meta&gt;]
</pre></div><div class="public" id="var-get-basic-reply"><h3>get-basic-reply</h3><div class="usage"><code>(get-basic-reply in raw?)</code></div><pre class="doc">BLOCKS to receive a single reply from Redis server. Applies basic parsing
and returns the result.

Redis will reply to commands with different kinds of replies, identified by
their first byte:
    * `+` for single line reply.
    * `-` for error message.
    * `:` for integer reply.
    * `$` for bulk reply.
    * `*` for multi bulk reply.</pre></div><div class="public" id="var-get-parsed-replies"><h3>get-parsed-replies</h3><div class="usage"><code>(get-parsed-replies as-pipeline?)</code></div><pre class="doc">Implementation detail.
BLOCKS to receive queued (pipelined) replies from Redis server. Applies all
parsing and returns the result. Note that Redis returns replies as a FIFO
queue per connection.</pre></div><div class="public" id="var-map-%3EContext"><h3>map-&gt;Context</h3><div class="usage"><code>(map-&gt;Context m__5818__auto__)</code></div><pre class="doc">Factory function for class taoensso.carmine.protocol.Context, taking a map of keywords to field values.
</pre></div><div class="public" id="var-map-%3EWrappedRaw"><h3>map-&gt;WrappedRaw</h3><div class="usage"><code>(map-&gt;WrappedRaw m__5818__auto__)</code></div><pre class="doc">Factory function for class taoensso.carmine.protocol.WrappedRaw, taking a map of keywords to field values.
</pre></div><div class="public" id="var-parse"><h3>parse</h3><h4 class="macro">macro</h4><div class="usage"><code>(parse f &amp; body)</code></div><pre class="doc">Wraps body so that replies to any wrapped Redis commands will be parsed with
`(f reply)`. Replaces any current parser; removes parser when `f` is nil.
See also `parser-comp`.</pre></div><div class="public" id="var-parser-comp"><h3>parser-comp</h3><div class="usage"><code>(parser-comp f g)</code></div><pre class="doc">Composes parsers when f or g are nnil, preserving metadata.
</pre></div><div class="public" id="var-raw"><h3>raw</h3><div class="usage"><code>(raw x)</code></div><pre class="doc">Forces byte[] argument to be sent to Redis as raw, unencoded bytes.
</pre></div><div class="public" id="var-return"><h3>return</h3><div class="usage"><code>(return value)</code></div><pre class="doc">Takes value and returns it unchanged as part of next reply from Redis server.
Unlike `echo`, does not actually send any data to Redis.</pre></div><div class="public" id="var-send-request"><h3>send-request</h3><div class="usage"><code>(send-request args)</code></div><pre class="doc">Sends a command to Redis server using its byte string protocol:
*&lt;no. of args&gt;     crlf
[$&lt;size of arg N&gt;  crlf
  &lt;arg data&gt;       crlf ...]</pre></div><div class="public" id="var-with-context"><h3>with-context</h3><h4 class="macro">macro</h4><div class="usage"><code>(with-context conn &amp; body)</code></div><pre class="doc">Evaluates body in the context of a thread-bound connection to a Redis server.
</pre></div><div class="public" id="var-with-replies"><h3>with-replies</h3><h4 class="macro">macro</h4><div class="usage"><code>(with-replies :as-pipeline &amp; body)</code><code>(with-replies &amp; body)</code></div><pre class="doc">Alpha - subject to change.
Evaluates body, immediately returning the server's response to any contained
Redis commands (i.e. before enclosing context ends).

As an implementation detail, stashes and then `return`s any replies already
queued with Redis server: i.e. should be compatible with pipelining.

Note on parsers: if you're writing a Redis command (e.g. a fn that is intended
to execute w/in an implicit connection context) and you're using `with-replies`
as an implementation detail (i.e. you're interpreting replies internally), you
probably want `(parse nil (with-replies ...))` to keep external parsers from
leaking into your internal logic.</pre></div></div></body></html>