<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>taoensso.carmine.protocol documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Carmine 2.5.0 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li><a href="taoensso.carmine.html"><span>taoensso.carmine</span></a></li><li><a href="taoensso.carmine.benchmarks.html"><span>taoensso.carmine.benchmarks</span></a></li><li><a href="taoensso.carmine.commands.html"><span>taoensso.carmine.commands</span></a></li><li><a href="taoensso.carmine.connections.html"><span>taoensso.carmine.connections</span></a></li><li><a href="taoensso.carmine.locks.html"><span>taoensso.carmine.locks</span></a></li><li><a href="taoensso.carmine.message-queue.html"><span>taoensso.carmine.message-queue</span></a></li><li class="current"><a href="taoensso.carmine.protocol.html"><span>taoensso.carmine.protocol</span></a></li><li><a href="taoensso.carmine.ring.html"><span>taoensso.carmine.ring</span></a></li><li><a href="taoensso.carmine.tundra.html"><span>taoensso.carmine.tundra</span></a></li><li><a href="taoensso.carmine.tundra.carmine.html"><span>taoensso.carmine.tundra.carmine</span></a></li><li><a href="taoensso.carmine.tundra.disk.html"><span>taoensso.carmine.tundra.disk</span></a></li><li><a href="taoensso.carmine.tundra.faraday.html"><span>taoensso.carmine.tundra.faraday</span></a></li><li><a href="taoensso.carmine.tundra.s3.html"><span>taoensso.carmine.tundra.s3</span></a></li><li><a href="taoensso.carmine.utils.html"><span>taoensso.carmine.utils</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="taoensso.carmine.protocol.html#var-*context*"><span>*context*</span></a></li><li><a href="taoensso.carmine.protocol.html#var-*parser*"><span>*parser*</span></a></li><li><a href="taoensso.carmine.protocol.html#var--%3EContext"><span>-&gt;Context</span></a></li><li><a href="taoensso.carmine.protocol.html#var--%3EWrappedRaw"><span>-&gt;WrappedRaw</span></a></li><li><a href="taoensso.carmine.protocol.html#var-IRedisArg"><span>IRedisArg</span></a></li><li><a href="taoensso.carmine.protocol.html#var-bs-%24"><span>bs-$</span></a></li><li><a href="taoensso.carmine.protocol.html#var-bs-*"><span>bs-*</span></a></li><li><a href="taoensso.carmine.protocol.html#var-bs-bin"><span>bs-bin</span></a></li><li><a href="taoensso.carmine.protocol.html#var-bs-clj"><span>bs-clj</span></a></li><li><a href="taoensso.carmine.protocol.html#var-bs-crlf"><span>bs-crlf</span></a></li><li><a href="taoensso.carmine.protocol.html#var-coerce-bs"><span>coerce-bs</span></a></li><li><a href="taoensso.carmine.protocol.html#var-execute-requests"><span>execute-requests</span></a></li><li><a href="taoensso.carmine.protocol.html#var-get-parsed-reply"><span>get-parsed-reply</span></a></li><li><a href="taoensso.carmine.protocol.html#var-get-unparsed-reply"><span>get-unparsed-reply</span></a></li><li><a href="taoensso.carmine.protocol.html#var-map-%3EContext"><span>map-&gt;Context</span></a></li><li><a href="taoensso.carmine.protocol.html#var-map-%3EWrappedRaw"><span>map-&gt;WrappedRaw</span></a></li><li><a href="taoensso.carmine.protocol.html#var-no-context-ex"><span>no-context-ex</span></a></li><li><a href="taoensso.carmine.protocol.html#var-parse"><span>parse</span></a></li><li><a href="taoensso.carmine.protocol.html#var-parse-nippy"><span>parse-nippy</span></a></li><li><a href="taoensso.carmine.protocol.html#var-parse-raw"><span>parse-raw</span></a></li><li><a href="taoensso.carmine.protocol.html#var-parser-comp"><span>parser-comp</span></a></li><li><a href="taoensso.carmine.protocol.html#var-raw"><span>raw</span></a></li><li><a href="taoensso.carmine.protocol.html#var-return"><span>return</span></a></li><li><a href="taoensso.carmine.protocol.html#var-with-context"><span>with-context</span></a></li><li><a href="taoensso.carmine.protocol.html#var-with-replies"><span>with-replies</span></a></li><li><a href="taoensso.carmine.protocol.html#var-with-replies*"><span>with-replies*</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>taoensso.carmine.protocol documentation</h2><pre class="doc">Facilities for actually communicating with Redis server using its
request/response protocol. Originally adapted from Accession.

Ref: http://redis.io/topics/protocol</pre><div class="public" id="var-*context*"><h3>*context*</h3><div class="usage"></div><pre class="doc"></pre></div><div class="public" id="var-*parser*"><h3>*parser*</h3><div class="usage"></div><pre class="doc"></pre></div><div class="public" id="var--%3EContext"><h3>-&gt;Context</h3><div class="usage"><code>(-&gt;Context conn req-queue)</code></div><pre class="doc">Positional factory function for class taoensso.carmine.protocol.Context.
</pre></div><div class="public" id="var--%3EWrappedRaw"><h3>-&gt;WrappedRaw</h3><div class="usage"><code>(-&gt;WrappedRaw ba)</code></div><pre class="doc">Positional factory function for class taoensso.carmine.protocol.WrappedRaw.
</pre></div><div class="public" id="var-IRedisArg"><h3>IRedisArg</h3><div class="usage"></div><pre class="doc"></pre></div><div class="public" id="var-bs-%24"><h3>bs-$</h3><div class="usage"></div><pre class="doc"></pre></div><div class="public" id="var-bs-*"><h3>bs-*</h3><div class="usage"></div><pre class="doc"></pre></div><div class="public" id="var-bs-bin"><h3>bs-bin</h3><div class="usage"></div><pre class="doc"></pre></div><div class="public" id="var-bs-clj"><h3>bs-clj</h3><div class="usage"></div><pre class="doc"></pre></div><div class="public" id="var-bs-crlf"><h3>bs-crlf</h3><div class="usage"></div><pre class="doc"></pre></div><div class="public" id="var-coerce-bs"><h3>coerce-bs</h3><div class="usage"><code>(coerce-bs x)</code></div><pre class="doc">Coerces arbitrary Clojure value to RESP arg, by type.
</pre></div><div class="public" id="var-execute-requests"><h3>execute-requests</h3><div class="usage"><code>(execute-requests get-replies? replies-as-pipeline?)</code><code>(execute-requests conn requests get-replies? replies-as-pipeline?)</code></div><pre class="doc">Implementation detail.
Sends given/dynamic requests to given/dynamic Redis server and optionally
blocks to receive the relevant queued (pipelined) parsed replies.</pre></div><div class="public" id="var-get-parsed-reply"><h3>get-parsed-reply</h3><div class="usage"><code>(get-parsed-reply in ?parser)</code></div><pre class="doc">Implementation detail.
</pre></div><div class="public" id="var-get-unparsed-reply"><h3>get-unparsed-reply</h3><div class="usage"><code>(get-unparsed-reply in req-opts)</code></div><pre class="doc">Implementation detail.
BLOCKS to receive a single reply from Redis server and returns the result as
[&lt;type&gt; &lt;reply&gt;]. Redis will reply to commands with different kinds of replies,
identified by their first byte, Ref. http://redis.io/topics/protocol:

  * `+` for simple strings -&gt; &lt;string&gt;
  * `:` for integers       -&gt; &lt;long&gt;
  * `-` for error strings  -&gt; &lt;ex-info&gt;
  * `$` for bulk strings   -&gt; &lt;clj&gt;/&lt;raw-bytes&gt;    ; Marked as serialized
                           -&gt; &lt;bytes&gt;/&lt;raw-bytes&gt;  ; Marked as binary
                           -&gt; &lt;string&gt;/&lt;raw-bytes&gt; ; Unmarked
                           -&gt; nil
  * `*` for arrays         -&gt; &lt;vector&gt;
                           -&gt; nil</pre></div><div class="public" id="var-map-%3EContext"><h3>map-&gt;Context</h3><div class="usage"><code>(map-&gt;Context m__5869__auto__)</code></div><pre class="doc">Factory function for class taoensso.carmine.protocol.Context, taking a map of keywords to field values.
</pre></div><div class="public" id="var-map-%3EWrappedRaw"><h3>map-&gt;WrappedRaw</h3><div class="usage"><code>(map-&gt;WrappedRaw m__5869__auto__)</code></div><pre class="doc">Factory function for class taoensso.carmine.protocol.WrappedRaw, taking a map of keywords to field values.
</pre></div><div class="public" id="var-no-context-ex"><h3>no-context-ex</h3><div class="usage"></div><pre class="doc"></pre></div><div class="public" id="var-parse"><h3>parse</h3><h4 class="macro">macro</h4><div class="usage"><code>(parse f &amp; body)</code></div><pre class="doc">Wraps body so that replies to any wrapped Redis commands will be parsed with
`(f reply)`. Replaces any current parser; removes parser when `f` is nil.
See also `parser-comp`.</pre></div><div class="public" id="var-parse-nippy"><h3>parse-nippy</h3><h4 class="macro">macro</h4><div class="usage"><code>(parse-nippy thaw-opts &amp; body)</code></div><pre class="doc"></pre></div><div class="public" id="var-parse-raw"><h3>parse-raw</h3><h4 class="macro">macro</h4><div class="usage"><code>(parse-raw &amp; body)</code></div><pre class="doc"></pre></div><div class="public" id="var-parser-comp"><h3>parser-comp</h3><div class="usage"><code>(parser-comp f g)</code></div><pre class="doc">Composes parsers when f or g are nnil, preserving metadata.
</pre></div><div class="public" id="var-raw"><h3>raw</h3><div class="usage"><code>(raw x)</code></div><pre class="doc">Forces byte[] argument to be sent to Redis as raw, unencoded bytes.
</pre></div><div class="public" id="var-return"><h3>return</h3><div class="usage"><code>(return value)</code></div><pre class="doc">Takes value and returns it unchanged as part of next reply from Redis server.
Unlike `echo`, does not actually send any data to Redis.</pre></div><div class="public" id="var-with-context"><h3>with-context</h3><h4 class="macro">macro</h4><div class="usage"><code>(with-context conn &amp; body)</code></div><pre class="doc">Implementation detail.
</pre></div><div class="public" id="var-with-replies"><h3>with-replies</h3><h4 class="macro">macro</h4><div class="usage"><code>(with-replies :as-pipeline &amp; body)</code><code>(with-replies &amp; body)</code></div><pre class="doc">Alpha - subject to change.
Evaluates body, immediately returning the server's response to any contained
Redis commands (i.e. before enclosing context ends).

As an implementation detail, stashes and then `return`s any replies already
queued with Redis server: i.e. should be compatible with pipelining.

Note on parsers: if you're writing a Redis command (e.g. a fn that is intended
to execute w/in an implicit connection context) and you're using `with-replies`
as an implementation detail (i.e. you're interpreting replies internally), you
probably want `(parse nil (with-replies ...))` to keep external parsers from
leaking into your internal logic.</pre></div><div class="public" id="var-with-replies*"><h3>with-replies*</h3><h4 class="macro">macro</h4><div class="usage"><code>(with-replies* :as-pipeline &amp; body)</code><code>(with-replies* &amp; body)</code></div><pre class="doc">Implementation detail.
Light, fresh-context version of `with-replies`. Useful for consumers that'll
be in complete control of the connection/context.</pre></div></div></body></html>