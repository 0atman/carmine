<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>taoensso.carmine.message-queue documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Carmine 2.2.3 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li><a href="taoensso.carmine.html"><span>taoensso.carmine</span></a></li><li><a href="taoensso.carmine.benchmarks.html"><span>taoensso.carmine.benchmarks</span></a></li><li><a href="taoensso.carmine.commands.html"><span>taoensso.carmine.commands</span></a></li><li><a href="taoensso.carmine.connections.html"><span>taoensso.carmine.connections</span></a></li><li><a href="taoensso.carmine.locks.html"><span>taoensso.carmine.locks</span></a></li><li class="current"><a href="taoensso.carmine.message-queue.html"><span>taoensso.carmine.message-queue</span></a></li><li><a href="taoensso.carmine.protocol.html"><span>taoensso.carmine.protocol</span></a></li><li><a href="taoensso.carmine.ring.html"><span>taoensso.carmine.ring</span></a></li><li><a href="taoensso.carmine.tundra.html"><span>taoensso.carmine.tundra</span></a></li><li><a href="taoensso.carmine.tundra.faraday.html"><span>taoensso.carmine.tundra.faraday</span></a></li><li><a href="taoensso.carmine.utils.html"><span>taoensso.carmine.utils</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="taoensso.carmine.message-queue.html#var--%3EWorker"><span>-&gt;Worker</span></a></li><li><a href="taoensso.carmine.message-queue.html#var-IWorker"><span>IWorker</span></a></li><li><a href="taoensso.carmine.message-queue.html#var-clear-queues"><span>clear-queues</span></a></li><li><a href="taoensso.carmine.message-queue.html#var-dequeue"><span>dequeue</span></a></li><li><a href="taoensso.carmine.message-queue.html#var-enqueue"><span>enqueue</span></a></li><li><a href="taoensso.carmine.message-queue.html#var-exp-backoff"><span>exp-backoff</span></a></li><li><a href="taoensso.carmine.message-queue.html#var-make-dequeue-worker"><span>make-dequeue-worker</span></a></li><li><a href="taoensso.carmine.message-queue.html#var-map-%3EWorker"><span>map-&gt;Worker</span></a></li><li><a href="taoensso.carmine.message-queue.html#var-message-status"><span>message-status</span></a></li><li><a href="taoensso.carmine.message-queue.html#var-qkey"><span>qkey</span></a></li><li><a href="taoensso.carmine.message-queue.html#var-queue-status"><span>queue-status</span></a></li><li><a href="taoensso.carmine.message-queue.html#var-start"><span>start</span></a></li><li><a href="taoensso.carmine.message-queue.html#var-stop"><span>stop</span></a></li><li><a href="taoensso.carmine.message-queue.html#var-worker"><span>worker</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>taoensso.carmine.message-queue documentation</h2><pre class="doc">Carmine-backed Clojure message queue. All heavy lifting by Redis (2.6+).
Simple implementation. Very simple API. Reliable. Fast.

Redis keys:
  * carmine:mq:&lt;qname&gt;:messages      -&gt; hash, {mid mcontent}.
  * carmine:mq:&lt;qname&gt;:locks         -&gt; hash, {mid lock-expiry-time}.
  * carmine:mq:&lt;qname&gt;:backoffs      -&gt; hash, {mid backoff-expiry-time}.
  * carmine:mq:&lt;qname&gt;:retry-counts  -&gt; hash, {mid count}.
  * carmine:mq:&lt;qname&gt;:mid-circle    -&gt; list, rotating list of mids.
  * carmine:mq:&lt;qname&gt;:recently-done -&gt; set, for efficient mid removal from circle.
  * carmine:mq:&lt;qname&gt;:eoq-backoff?  -&gt; ttl flag, used for queue-wide (every-worker)
                                        polling backoff.
  * carmine:mq:&lt;qname&gt;:dry-runs      -&gt; int, number of times worker(s) have burnt
                                        through queue w/o work to do.

Ref. http://antirez.com/post/250 for basic implementation details.</pre><div class="public" id="var--%3EWorker"><h3>-&gt;Worker</h3><div class="usage"><code>(-&gt;Worker conn qname running? opts)</code></div><pre class="doc">Positional factory function for class taoensso.carmine.message_queue.Worker.
</pre></div><div class="public" id="var-IWorker"><h3>IWorker</h3><div class="usage"></div><pre class="doc"></pre></div><div class="public" id="var-clear-queues"><h3>clear-queues</h3><div class="usage"><code>(clear-queues conn &amp; qnames)</code></div><pre class="doc"></pre></div><div class="public" id="var-dequeue"><h3>dequeue</h3><div class="usage"><code>(dequeue qname &amp; [{:keys [lock-ms eoq-backoff-ms], :or {lock-ms (* 60 60 1000), eoq-backoff-ms 2000}}])</code></div><pre class="doc">IMPLEMENTATION DETAIL: Use `worker` instead.
Rotates queue's mid-circle and processes next mid. Returns:
  nil             - If msg locked, recently GC'd, or set to backoff.
  &quot;eoq-backoff&quot; - If circle uninitialized or end-of-circle marker reached.
  [&lt;mid&gt; &lt;mcontent&gt; &lt;attempt-count&gt;] - If message should be (re)handled now.</pre></div><div class="public" id="var-enqueue"><h3>enqueue</h3><div class="usage"><code>(enqueue qname message)</code></div><pre class="doc">Pushes given message (any Clojure datatype) to named queue and returns a
unique message id.</pre></div><div class="public" id="var-exp-backoff"><h3>exp-backoff</h3><div class="usage"><code>(exp-backoff attempt &amp; [{:keys [factor min max], :or {factor 2000}}])</code></div><pre class="doc">Returns binary exponential backoff value.
</pre></div><div class="public" id="var-make-dequeue-worker"><h3>make-dequeue-worker</h3><div class="usage"><code>(make-dequeue-worker pool spec &amp; {:keys [handler-fn handler-ttl-msecs backoff-msecs throttle-msecs auto-start?]})</code></div><pre class="doc">DEPRECATED: Use `worker` instead.
</pre></div><div class="public" id="var-map-%3EWorker"><h3>map-&gt;Worker</h3><div class="usage"><code>(map-&gt;Worker m__5818__auto__)</code></div><pre class="doc">Factory function for class taoensso.carmine.message_queue.Worker, taking a map of keywords to field values.
</pre></div><div class="public" id="var-message-status"><h3>message-status</h3><div class="usage"><code>(message-status conn qname mid)</code></div><pre class="doc">Returns current message status, e/o:
:queued        - Waiting for processing.
:locked        - Currently processing.
:recently-done - Finished processing, waiting for GC.
:backoff       - Waiting for retry after handler-imposed backoff.
nil            - Unknown status, or invalid message id.</pre></div><div class="public" id="var-qkey"><h3>qkey</h3><div class="usage"></div><pre class="doc">Prefixed queue key
</pre></div><div class="public" id="var-queue-status"><h3>queue-status</h3><div class="usage"><code>(queue-status conn qname)</code></div><pre class="doc"></pre></div><div class="public" id="var-start"><h3>start</h3><div class="usage"><code>(start this)</code></div><pre class="doc"></pre></div><div class="public" id="var-stop"><h3>stop</h3><div class="usage"><code>(stop this)</code></div><pre class="doc"></pre></div><div class="public" id="var-worker"><h3>worker</h3><div class="usage"><code>(worker conn qname &amp; [{:keys [handler lock-ms eoq-backoff-ms throttle-ms auto-start?], :or {handler (fn [{:keys [message attempt]}] (timbre/info qname message attempt) {:status :success}), lock-ms (* 60 60 1000), throttle-ms 200, eoq-backoff-ms (fn [druns] (exp-backoff druns {:max 10000})), auto-start? true}}])</code></div><pre class="doc">Returns a threaded worker to poll for and handle messages `enqueue`'d to
named queue. Options:
 :handler        - (fn [{:keys [message attempt]}]) that throws an exception
                   or returns {:status     &lt;#{:success :error :retry}&gt;
                               :throwable  &lt;Throwable&gt;
                               :backoff-ms &lt;retry-backoff-ms}.
 :lock-ms        - Max time handler may keep a message before handler
                   considered fatally stalled and message re-queued. Must be
                   sufficiently high to prevent double handling.
 :eoq-backoff-ms - Thread sleep period each time end of queue is reached.
                   Can be a (fn [dry-runs]) =&gt; ms. Sleep synchronized for all
                   queue workers.
 :throttle-ms    - Thread sleep period between each poll.</pre></div></div></body></html>