<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>taoensso.carmine.message-queue documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Carmine 2.4.0 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li><a href="taoensso.carmine.html"><span>taoensso.carmine</span></a></li><li><a href="taoensso.carmine.benchmarks.html"><span>taoensso.carmine.benchmarks</span></a></li><li><a href="taoensso.carmine.commands.html"><span>taoensso.carmine.commands</span></a></li><li><a href="taoensso.carmine.connections.html"><span>taoensso.carmine.connections</span></a></li><li><a href="taoensso.carmine.locks.html"><span>taoensso.carmine.locks</span></a></li><li class="current"><a href="taoensso.carmine.message-queue.html"><span>taoensso.carmine.message-queue</span></a></li><li><a href="taoensso.carmine.protocol.html"><span>taoensso.carmine.protocol</span></a></li><li><a href="taoensso.carmine.ring.html"><span>taoensso.carmine.ring</span></a></li><li><a href="taoensso.carmine.tundra.html"><span>taoensso.carmine.tundra</span></a></li><li><a href="taoensso.carmine.tundra.carmine.html"><span>taoensso.carmine.tundra.carmine</span></a></li><li><a href="taoensso.carmine.tundra.disk.html"><span>taoensso.carmine.tundra.disk</span></a></li><li><a href="taoensso.carmine.tundra.faraday.html"><span>taoensso.carmine.tundra.faraday</span></a></li><li><a href="taoensso.carmine.tundra.s3.html"><span>taoensso.carmine.tundra.s3</span></a></li><li><a href="taoensso.carmine.utils.html"><span>taoensso.carmine.utils</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="taoensso.carmine.message-queue.html#var--%3EWorker"><span>-&gt;Worker</span></a></li><li><a href="taoensso.carmine.message-queue.html#var-IWorker"><span>IWorker</span></a></li><li><a href="taoensso.carmine.message-queue.html#var-clear-queues"><span>clear-queues</span></a></li><li><a href="taoensso.carmine.message-queue.html#var-dequeue"><span>dequeue</span></a></li><li><a href="taoensso.carmine.message-queue.html#var-enqueue"><span>enqueue</span></a></li><li><a href="taoensso.carmine.message-queue.html#var-exp-backoff"><span>exp-backoff</span></a></li><li><a href="taoensso.carmine.message-queue.html#var-handle1"><span>handle1</span></a></li><li><a href="taoensso.carmine.message-queue.html#var-make-dequeue-worker"><span>make-dequeue-worker</span></a></li><li><a href="taoensso.carmine.message-queue.html#var-map-%3EWorker"><span>map-&gt;Worker</span></a></li><li><a href="taoensso.carmine.message-queue.html#var-message-status"><span>message-status</span></a></li><li><a href="taoensso.carmine.message-queue.html#var-monitor-fn"><span>monitor-fn</span></a></li><li><a href="taoensso.carmine.message-queue.html#var-qkey"><span>qkey</span></a></li><li><a href="taoensso.carmine.message-queue.html#var-queue-status"><span>queue-status</span></a></li><li><a href="taoensso.carmine.message-queue.html#var-start"><span>start</span></a></li><li><a href="taoensso.carmine.message-queue.html#var-stop"><span>stop</span></a></li><li><a href="taoensso.carmine.message-queue.html#var-worker"><span>worker</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>taoensso.carmine.message-queue documentation</h2><pre class="doc">Carmine-backed Clojure message queue. All heavy lifting by Redis (2.6+).
Simple implementation. Very simple API. Reliable. Fast.

Redis keys:
  * carmine:mq:&lt;qname&gt;:messages     -&gt; hash, {mid mcontent}.
  * carmine:mq:&lt;qname&gt;:locks        -&gt; hash, {mid lock-expiry-time}.
  * carmine:mq:&lt;qname&gt;:backoffs     -&gt; hash, {mid backoff-expiry-time}.
  * carmine:mq:&lt;qname&gt;:nattempts    -&gt; hash, {mid attempt-count}.
  * carmine:mq:&lt;qname&gt;:mid-circle   -&gt; list, rotating list of mids.
  * carmine:mq:&lt;qname&gt;:done         -&gt; set, awaiting gc, requeue, etc.
  * carmine:mq:&lt;qname&gt;:requeue      -&gt; set, for `allow-requeue?` option.
  * carmine:mq:&lt;qname&gt;:eoq-backoff? -&gt; ttl flag, used for queue-wide (every-worker)
                                       polling backoff.
  * carmine:mq:&lt;qname&gt;:ndry-runs    -&gt; int, number of times worker(s) have burnt
                                       through queue w/o work to do.

Ref. http://antirez.com/post/250 for basic implementation details.</pre><div class="public" id="var--%3EWorker"><h3>-&gt;Worker</h3><div class="usage"><code>(-&gt;Worker conn qname running? opts)</code></div><pre class="doc">Positional factory function for class taoensso.carmine.message_queue.Worker.
</pre></div><div class="public" id="var-IWorker"><h3>IWorker</h3><div class="usage"></div><pre class="doc"></pre></div><div class="public" id="var-clear-queues"><h3>clear-queues</h3><div class="usage"><code>(clear-queues conn &amp; qnames)</code></div><pre class="doc"></pre></div><div class="public" id="var-dequeue"><h3>dequeue</h3><div class="usage"><code>(dequeue qname &amp; [{:keys [lock-ms eoq-backoff-ms], :or {lock-ms (* 1000 60 60), eoq-backoff-ms exp-backoff}}])</code></div><pre class="doc">IMPLEMENTATION DETAIL: Use `worker` instead.
Rotates queue's mid-circle and processes next mid. Returns:
  nil             - If msg GC'd, locked, or set to backoff.
  &quot;eoq-backoff&quot; - If circle uninitialized or end-of-circle marker reached.
  [&lt;mid&gt; &lt;mcontent&gt; &lt;attempt&gt;] - If message should be (re)handled now.</pre></div><div class="public" id="var-enqueue"><h3>enqueue</h3><div class="usage"><code>(enqueue qname message &amp; [unique-message-id allow-requeue?])</code></div><pre class="doc">Pushes given message (any Clojure datatype) to named queue and returns unique
message id or {:carmine.mq/error &lt;message-status&gt;}.
Options:
  unique-message-id  - Specify an explicit message id (e.g. message hash) to
                       perform a de-duplication check. If unspecified, a unique
                       message id will be auto-generated.
  allow-requeue?     - Alpha - subject to change.
                       When true, allow buffered escrow-requeue for a message
                       in the :locked or :done-with-backoff state.</pre></div><div class="public" id="var-exp-backoff"><h3>exp-backoff</h3><div class="usage"><code>(exp-backoff attempt &amp; [{:keys [factor min max], :or {factor 2200}}])</code></div><pre class="doc">Returns binary exponential backoff value.
</pre></div><div class="public" id="var-handle1"><h3>handle1</h3><div class="usage"><code>(handle1 conn qname handler [mid mcontent attempt :as poll-reply])</code></div><pre class="doc">Implementation detail!
</pre></div><div class="public" id="var-make-dequeue-worker"><h3>make-dequeue-worker</h3><div class="usage"><code>(make-dequeue-worker pool spec &amp; {:keys [handler-fn handler-ttl-msecs backoff-msecs throttle-msecs auto-start?]})</code></div><pre class="doc">DEPRECATED: Use `worker` instead.
</pre></div><div class="public" id="var-map-%3EWorker"><h3>map-&gt;Worker</h3><div class="usage"><code>(map-&gt;Worker m__5818__auto__)</code></div><pre class="doc">Factory function for class taoensso.carmine.message_queue.Worker, taking a map of keywords to field values.
</pre></div><div class="public" id="var-message-status"><h3>message-status</h3><div class="usage"><code>(message-status qname mid)</code></div><pre class="doc">Returns current message status, e/o:
:queued               - Awaiting handler.
:queued-with-backoff  - Awaiting rehandling.
:locked               - Currently with handler.
:locked-with-requeue  - Currently with handler, will requeue on success.
:done-awaiting-gc     - Finished handling, awaiting GC.
:done-with-backoff    - Finished handling, awaiting dedupe timeout.
nil                   - Already GC'd or invalid message id.</pre></div><div class="public" id="var-monitor-fn"><h3>monitor-fn</h3><div class="usage"><code>(monitor-fn qname max-circle-size warn-backoff-ms)</code></div><pre class="doc">Returns a worker monitor fn that warns when queue's mid-circle exceeds
the prescribed size. A backoff timeout can be provided to rate-limit this
warning.</pre></div><div class="public" id="var-qkey"><h3>qkey</h3><div class="usage"></div><pre class="doc">Prefixed queue key
</pre></div><div class="public" id="var-queue-status"><h3>queue-status</h3><div class="usage"><code>(queue-status conn qname)</code></div><pre class="doc"></pre></div><div class="public" id="var-start"><h3>start</h3><div class="usage"><code>(start this)</code></div><pre class="doc"></pre></div><div class="public" id="var-stop"><h3>stop</h3><div class="usage"><code>(stop this)</code></div><pre class="doc"></pre></div><div class="public" id="var-worker"><h3>worker</h3><div class="usage"><code>(worker conn qname &amp; [{:keys [handler monitor lock-ms eoq-backoff-ms nthreads throttle-ms auto-start], :as opts, :or {handler (fn [args] (timbre/infof &quot;%s&quot; args) {:status :success}), monitor (monitor-fn qname 1000 (* 1000 60 60 6)), lock-ms (* 1000 60 60), nthreads 1, throttle-ms 200, eoq-backoff-ms exp-backoff, auto-start true}}])</code></div><pre class="doc">Returns a threaded worker to poll for and handle messages `enqueue`'d to
named queue. Options:
 :handler        - (fn [{:keys [mid message attempt]}]) that throws an exception
                   or returns {:status     &lt;#{:success :error :retry}&gt;
                               :throwable  &lt;Throwable&gt;
                               :backoff-ms &lt;retry-or-dedupe-backoff-ms}.
 :monitor        - (fn [{:keys [mid-circle-size ndry-runs poll-reply]}]) called
                   on each worker loop iteration. Useful for queue
                   monitoring/logging. See also `monitor-fn`.
 :lock-ms        - Max time handler may keep a message before handler
                   considered fatally stalled and message re-queued. Must be
                   sufficiently high to prevent double handling.
 :eoq-backoff-ms - Thread sleep period each time end of queue is reached.
                   Can be a (fn [ndry-runs]) -&gt; ms (n&lt;=5) will be used.
                   Sleep synchronized for all queue workers.
 :nthreads       - Number of synchronized worker threads to use.
 :throttle-ms    - Thread sleep period between each poll.</pre></div></div></body></html>