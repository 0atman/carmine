<!DOCTYPE html>
<html><head><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>taoensso.carmine.message-queue documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Carmine 1.8.0 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li><a href="taoensso.carmine.html"><span>taoensso.carmine</span></a></li><li><a href="taoensso.carmine.commands.html"><span>taoensso.carmine.commands</span></a></li><li><a href="taoensso.carmine.connections.html"><span>taoensso.carmine.connections</span></a></li><li><a href="taoensso.carmine.locks.html"><span>taoensso.carmine.locks</span></a></li><li class="current"><a href="taoensso.carmine.message-queue.html"><span>taoensso.carmine.message-queue</span></a></li><li><a href="taoensso.carmine.protocol.html"><span>taoensso.carmine.protocol</span></a></li><li><a href="taoensso.carmine.ring.html"><span>taoensso.carmine.ring</span></a></li><li><a href="taoensso.carmine.utils.html"><span>taoensso.carmine.utils</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="taoensso.carmine.message-queue.html#var--%3EDequeueWorker"><span>-&gt;DequeueWorker</span></a></li><li><a href="taoensso.carmine.message-queue.html#var-dequeue-1"><span>dequeue-1</span></a></li><li><a href="taoensso.carmine.message-queue.html#var-enqueue"><span>enqueue</span></a></li><li><a href="taoensso.carmine.message-queue.html#var-make-dequeue-worker"><span>make-dequeue-worker</span></a></li><li><a href="taoensso.carmine.message-queue.html#var-map-%3EDequeueWorker"><span>map-&gt;DequeueWorker</span></a></li><li><a href="taoensso.carmine.message-queue.html#var-qkey"><span>qkey</span></a></li><li><a href="taoensso.carmine.message-queue.html#var-status"><span>status</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>taoensso.carmine.message-queue documentation</h2><pre class="doc">Alpha - subject to change.
Carmine-backed Clojure message queue. All heavy lifting by Redis (2.6+).
Simple implementation. Very simple API. Reliable. Fast.

Redis keys:
  * carmine:mq:&lt;qname&gt;:messages      -&gt; hash, {id content}
  * carmine:mq:&lt;qname&gt;:locks         -&gt; hash, {id lock-acquired-time}
  * carmine:mq:&lt;qname&gt;:id-circle     -&gt; list, rotating list of ids
  * carmine:mq:&lt;qname&gt;:recently-done -&gt; set, used for efficient id removal from
                                        circle
  * carmine:mq:&lt;qname&gt;:backoff?      -&gt; ttl flag, used for queue-wide (every-worker)
                                        polling backoff

Ref. http://antirez.com/post/250 for implementation details.</pre><div class="public" id="var--%3EDequeueWorker"><h3>-&gt;DequeueWorker</h3><div class="usage"><code>(-&gt;DequeueWorker pool spec qname opts active?)</code></div><pre class="doc">Positional factory function for class taoensso.carmine.message_queue.DequeueWorker.
</pre></div><div class="public" id="var-dequeue-1"><h3>dequeue-1</h3><div class="usage"><code>(dequeue-1 qname &amp; {:keys [handler-ttl-msecs backoff-msecs worker-context?], :or {handler-ttl-msecs (* 60 60 1000), backoff-msecs 2000}})</code></div><pre class="doc">Rotates queue's id-circle and processes next id. Returns:
  * nil if id is locked or was just garbage collected (i.e. previously marked
    as done).
  * &quot;backoff&quot; if circle is uninitialized or sentinel (end of circle) has
    been reached.
  * [message-id message &quot;new&quot;] or [message-id message &quot;retry&quot;] if message
    should be (re)handled now.

Exposes implementation details: prefer `make-dequeue-worker` when possible.</pre></div><div class="public" id="var-enqueue"><h3>enqueue</h3><div class="usage"><code>(enqueue qname message)</code></div><pre class="doc">Pushes given message (any Clojure datatype) to named queue. Returns message
id and the number of messages currently queued or recently dequeued.</pre></div><div class="public" id="var-make-dequeue-worker"><h3>make-dequeue-worker</h3><div class="usage"><code>(make-dequeue-worker connection-pool connection-spec qname &amp; {:keys [handler-fn handler-ttl-msecs throttle-msecs backoff-msecs auto-start?], :or {handler-fn (fn [msg] (timbre/info (str &quot;Message received from queue: &quot; qname &quot;\n&quot;) msg)), handler-ttl-msecs (* 60 60 1000), throttle-msecs 200, backoff-msecs 2000, auto-start? true}})</code></div><pre class="doc">Creates a threaded worker to poll for and handle messages pushed to named
queue.
  * `handler-fn` should be a unary fn of dequeued messages (presumably with
    side-effects).
  * `handler-ttl-msecs` specifies how long a handler may keep a message
    before that handler is considered fatally stalled and the message
    re-activated in queue. BEWARE the risk of duplicate processing if ttl is
    too low.
  * `throttle-msecs` specifies thread sleep period between each poll.
  * `backoff-msecs` specifies thread sleep period each time end of queue is
    reached. Backoff is synchronized between all dequeue workers.</pre></div><div class="public" id="var-map-%3EDequeueWorker"><h3>map-&gt;DequeueWorker</h3><div class="usage"><code>(map-&gt;DequeueWorker m__5818__auto__)</code></div><pre class="doc">Factory function for class taoensso.carmine.message_queue.DequeueWorker, taking a map of keywords to field values.
</pre></div><div class="public" id="var-qkey"><h3>qkey</h3><div class="usage"></div><pre class="doc">Prefixed queue key
</pre></div><div class="public" id="var-status"><h3>status</h3><div class="usage"><code>(status qname msg-id &amp; {:keys [handler-ttl-msecs], :or {handler-ttl-msecs (* 60 60 1000)}})</code></div><pre class="doc">Returns current job status, or nil if unknown.
</pre></div></div></body></html>