#+STARTUP: overview, hidestars
#+TAGS: urgent in-progress maybe waiting hammock
* Docs
* API
** Investigate support for byte[] in/out support                      :maybe:
IN: Carmine already transparently supports byte[] args.
OUT: Perhaps offer a *with-bytes* binding or similar to suppress auto string
conversion for bulk replies? Could be a *context* thing?

One problem is that this binding would affect _all_ replies in a context
(pipeline).
** More elaborate response parsing?                           :maybe:hammock:
Integers, bools, etc.?

Or even prn or deep-freeze serialization (via byte[] support). Would this be
desirable? Might be better left to library consumer unless it could be light,
optional, and simple. [Upd: the new send-request! API is *very* flexible here]

(comment
  (defn encode  [x] (binding [*print-dup* true] (pr-str x)))
  (defn decode  [x] (with-in-str x (read)))
  (defn decode2 [x] (read-string x))

  (time (dotimes [n 100000] (decode  (encode true))))
  (time (dotimes [n 100000] (decode2 (encode true))))
  (decode (encode "true")))

The problem with serialization (incl. pr-str) is that we need a way to be sure
it will never get in the way when we don't want it. We've either got to allow
it to be selectively turned on and off _per command_ (e.g. by defining 2 fns
for each command that each use a different protocol *context*). OR we need it
to be smart:

e.g. strings -> strings. nums -> nums. Anything else goes to "^<serialized
payload>" string. We can then look for the "^" tag when parsing replies to
trigger a deserialization call.

Either way should be turn this off. Would also be nice if the actual
serialization stuff was user-pluggable (maybe via *context*)?

Going to require some hammock time.

UPD: New bytestring API provides an obvious, easy hook for something like
this... we could dispatch bytestring fn by type (e.g. a Sendable protocol with
bytestring [this] fn).

Then string -> (.getBytes ^String this charset)
other stuff -> (.getBytes (str "`clj`" this) charset), etc.

We'd also need to look for numbers and other things though - will require some
research to know what types Redis has functions for (e.g. incr, etc.).
** Pub/Sub reconnects support?                                      :waiting:
Waiting on Salvatore: https://github.com/antirez/redis/issues/420
Recall that reconnects would also require re-establishing p/subscriptions.
** More helper fns?
*** Transaction stuff
Helper(s) for mutli, watchers, etc.?

E.g. an atomic multi* helper to wrap some commands and auto-discard on a thrown
exception?

redis-clojure has some facilities like this, I think. Should be simple to
implement.

Likewise, watching should be trivial to impement with new Listener API.
* TESTS                                                              :urgent:
** Unit-test for all other commands (adapt from redis-clojure!!)     :urgent:
** Unit-test for sort* and Lua commands.                             :urgent:
Sort* test should be easily adaptable from redis-clojure
** Unit-test for very big requests (> output buffer size)            :urgent:
* Performance
** send-request! implementation could be more efficient
Marginally so.
Basically, we're currently calling (bytestring command-name) and then getting
its size _unnecessarily_. Both of these things _should_ be done during
defcommand.

The problem is that the Clojure reader doesn't support byte[]s, so passing
the pre-computed bytestrings is incredibly awkward.

Try find a way that isn't awkward.
